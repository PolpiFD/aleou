"""
Service de base de donn√©es pour l'orchestration des op√©rations Supabase
G√®re la logique m√©tier et les transactions complexes
"""

from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
import logging
import pandas as pd
import io
from .supabase_client import SupabaseClient, SupabaseError

# Configuration du logging
logger = logging.getLogger(__name__)


class DatabaseService:
    """Service de haut niveau pour les op√©rations de base de donn√©es"""

    # Mapping des colonnes Cvent vers les colonnes DB
    COLUMN_MAPPING = {
        # Variations pour surface
        'Taille': 'surface',
        'Taille de la salle': 'surface',
        'salle_taille': 'surface',

        # Variations pour th√©√¢tre
        'Th√©√¢tre': 'capacite_theatre',
        'th√©√¢tre': 'capacite_theatre',
        'capacite_theatre': 'capacite_theatre',

        # Variations pour classe
        'Salle de classe': 'capacite_classe',
        'salle de classe': 'capacite_classe',
        'capacite_classe': 'capacite_classe',

        # Variations pour banquet
        'En banquet': 'capacite_banquet',
        'en banquet': 'capacite_banquet',
        'capacite_banquet': 'capacite_banquet',

        # Variations pour cocktail
        'En cocktail': 'capacite_cocktail',
        'en cocktail': 'capacite_cocktail',
        'capacite_cocktail': 'capacite_cocktail',

        # Variations pour U
        'En U': 'capacite_u',
        'en u': 'capacite_u',
        'capacite_en_u': 'capacite_u',

        # Variations pour amphi
        'Amphith√©√¢tre': 'capacite_amphi',
        'Amphi': 'capacite_amphi',
        'amphith√©√¢tre': 'capacite_amphi',
        'amphi': 'capacite_amphi',

        # Nom de la salle
        'Salles de r√©union': 'nom_salle',
        'Nom': 'nom_salle',
        'nom': 'nom_salle',
        'salle_nom': 'nom_salle',

        # Capacit√© maximum (on ne garde pas dans la DB car redondant)
        'Capacit√© maximum': None,
        'Capacit√© max': None,
        'capacite_maximum': None,
    }

    def __init__(self):
        """Initialise le service de base de donn√©es"""
        try:
            self.client = SupabaseClient()
            logger.info("Service de base de donn√©es initialis√©")
        except SupabaseError as e:
            logger.error(f"Erreur initialisation service DB: {e}")
            raise

    def create_new_session(
        self,
        csv_filename: str,
        total_hotels: int
    ) -> str:
        """Cr√©e une nouvelle session d'extraction

        Args:
            csv_filename: Nom du fichier CSV
            total_hotels: Nombre total d'h√¥tels

        Returns:
            str: ID de la session cr√©√©e
        """
        session_name = f"Extraction {datetime.now().strftime('%Y-%m-%d %H:%M')}"

        try:
            session_id = self.client.create_extraction_session(
                session_name=session_name,
                total_hotels=total_hotels,
                csv_filename=csv_filename
            )
            logger.info(f"Session cr√©√©e: {session_id} pour {total_hotels} h√¥tels")
            return session_id
        except Exception as e:
            logger.error(f"Erreur cr√©ation session: {e}")
            raise

    def prepare_hotels_batch(
        self,
        session_id: str,
        hotels_data: List[Dict[str, str]]
    ) -> List[str]:
        """Pr√©pare un batch d'h√¥tels dans la DB

        Args:
            session_id: ID de la session
            hotels_data: Liste des donn√©es d'h√¥tels

        Returns:
            List[str]: Liste des IDs d'h√¥tels cr√©√©s
        """
        hotel_ids = []

        for hotel in hotels_data:
            try:
                hotel_id = self.client.insert_hotel(
                    session_id=session_id,
                    name=hotel.get('name', 'Unknown'),
                    address=hotel.get('address', ''),
                    cvent_url=hotel.get('url', '')
                )
                hotel_ids.append(hotel_id)
            except Exception as e:
                logger.error(f"Erreur insertion h√¥tel {hotel.get('name')}: {e}")
                continue

        logger.info(f"Batch pr√©par√©: {len(hotel_ids)} h√¥tels ins√©r√©s")
        return hotel_ids

    def map_cvent_data_to_db(
        self,
        headers: List[str],
        rows_data: List[List[str]]
    ) -> List[Dict[str, Any]]:
        """Mappe les donn√©es Cvent vers le format DB

        Args:
            headers: Headers extraits de Cvent
            rows_data: Donn√©es des salles

        Returns:
            List[Dict]: Donn√©es mapp√©es pour la DB
        """
        mapped_rooms = []

        for row in rows_data:
            room_data = {}

            for i, header in enumerate(headers):
                if i >= len(row):
                    continue

                # Obtenir le nom de colonne DB
                db_column = self.COLUMN_MAPPING.get(
                    header,
                    self.COLUMN_MAPPING.get(header.lower())
                )

                # Si pas de mapping ou mapping vers None, ignorer
                if db_column is None:
                    continue

                # Si pas dans le mapping, ignorer aussi
                if db_column == header and header not in [
                    'surface', 'capacite_theatre', 'capacite_classe',
                    'capacite_banquet', 'capacite_cocktail', 'capacite_u',
                    'capacite_amphi', 'nom_salle'
                ]:
                    continue

                # Ajouter la valeur
                value = row[i] if i < len(row) else None
                if value:
                    room_data[db_column] = value

            # S'assurer qu'on a au moins le nom de la salle
            if 'nom_salle' in room_data:
                mapped_rooms.append(room_data)
            elif row and row[0]:  # Fallback: premier √©l√©ment = nom
                room_data['nom_salle'] = row[0]
                mapped_rooms.append(room_data)

        logger.info(f"Mapp√© {len(mapped_rooms)} salles depuis Cvent")
        return mapped_rooms

    def process_hotel_extraction(
        self,
        hotel_id: str,
        cvent_result: Optional[Dict] = None,
        gmaps_result: Optional[Dict] = None,
        website_result: Optional[Dict] = None
    ) -> bool:
        """Traite l'extraction compl√®te d'un h√¥tel

        Args:
            hotel_id: ID de l'h√¥tel
            cvent_result: R√©sultat extraction Cvent
            gmaps_result: R√©sultat extraction Google Maps
            website_result: R√©sultat extraction Website

        Returns:
            bool: True si succ√®s
        """
        try:
            # Pr√©parer les donn√©es de l'h√¥tel
            hotel_update = {
                "id": hotel_id,
                "interface_type": None,
                "salles_count": 0
            }

            # Mapper les donn√©es Cvent si disponibles
            rooms_data = []
            if cvent_result and cvent_result.get('success'):
                hotel_update["interface_type"] = cvent_result['data'].get(
                    'interface_type'
                )

                # Mapper les donn√©es des salles
                headers = cvent_result['data'].get('headers', [])
                rows = cvent_result['data'].get('rows', [])

                if headers and rows:
                    rooms_data = self.map_cvent_data_to_db(headers, rows)
                    hotel_update["salles_count"] = len(rooms_data)

            # Pr√©parer les donn√©es Google Maps
            gmaps_data = None
            if gmaps_result and gmaps_result.get('extraction_status') == 'success':
                gmaps_data = gmaps_result

            # Pr√©parer les donn√©es Website
            website_data = None
            if website_result and website_result.get('success'):
                website_data = website_result.get('website_data')

            # Ins√©rer tout en transaction
            success = self.client.insert_hotel_with_rooms_transaction(
                hotel_data=hotel_update,
                rooms_data=rooms_data,
                gmaps_data=gmaps_data,
                website_data=website_data
            )

            if success:
                logger.info(
                    f"H√¥tel {hotel_id} trait√©: "
                    f"{len(rooms_data)} salles, "
                    f"GMaps: {gmaps_data is not None}, "
                    f"Website: {website_data is not None}"
                )

            return success

        except Exception as e:
            logger.error(f"Erreur traitement h√¥tel {hotel_id}: {e}")
            # Marquer comme √©chou√©
            try:
                self.client.update_hotel_status(
                    hotel_id=hotel_id,
                    status="failed",
                    error_message=str(e)
                )
            except:
                pass
            return False

    def process_batch_results(
        self,
        batch_results: List[Dict[str, Any]]
    ) -> Tuple[int, int]:
        """Traite les r√©sultats d'un batch d'extractions

        Args:
            batch_results: R√©sultats consolid√©s du batch

        Returns:
            Tuple[int, int]: (nombre de succ√®s, nombre d'√©checs)
        """
        logger.info(f"üîç DEBUT process_batch_results - {len(batch_results)} r√©sultats √† traiter")
        success_count = 0
        error_count = 0

        for i, result in enumerate(batch_results):
            logger.info(f"üîç Traitement r√©sultat {i+1}/{len(batch_results)}")
            try:
                # R√©cup√©rer l'ID de l'h√¥tel depuis le r√©sultat
                # (sera ajout√© par le parallel processor)
                hotel_id = result.get('hotel_id')
                logger.info(f"üîç Hotel ID r√©cup√©r√©: {hotel_id}")
                if not hotel_id:
                    logger.warning("R√©sultat sans hotel_id, ignor√©")
                    error_count += 1
                    continue

                # Traiter l'extraction avec protection suppl√©mentaire
                logger.info(f"üîç D√©but process_hotel_extraction pour hotel_id {hotel_id}")
                success = self.process_hotel_extraction(
                    hotel_id=hotel_id,
                    cvent_result=result.get('cvent_data'),
                    gmaps_result=result.get('gmaps_data'),
                    website_result=result.get('website_data')
                )
                logger.info(f"üîç Fin process_hotel_extraction pour hotel_id {hotel_id}, success={success}")

                if success:
                    success_count += 1
                else:
                    error_count += 1

            except Exception as hotel_error:
                logger.error(f"üí• Erreur critique sur h√¥tel {result.get('hotel_id', 'UNKNOWN')}: {hotel_error}")
                error_count += 1

        logger.info(f"üîç FIN process_batch_results: {success_count} succ√®s, {error_count} √©checs")
        return success_count, error_count

    def get_session_statistics(
        self,
        session_id: str
    ) -> Dict[str, Any]:
        """R√©cup√®re les statistiques d'une session

        Args:
            session_id: ID de la session

        Returns:
            Dict: Statistiques de la session
        """
        logger.info(f"üîç DEBUT get_session_statistics pour session_id={session_id}")
        try:
            stats = self.client.get_session_progress(session_id)
            logger.info(f"üîç Statistiques r√©cup√©r√©es: {stats}")
            return stats
        except Exception as e:
            logger.error(f"üîç Erreur r√©cup√©ration stats pour session_id={session_id}: {e}")
            return {}

    def _is_session_truly_inactive(self, session_data: Dict) -> bool:
        """D√©termine si une session est r√©ellement inactive bas√© sur last_activity

        Args:
            session_data: Donn√©es de la session depuis Supabase

        Returns:
            bool: True si la session est inactive depuis plus de 3 minutes
        """
        last_activity_str = session_data.get('last_activity')

        if not last_activity_str:
            # Pas de last_activity = session tr√®s ancienne ou cr√©√©e avant la mise √† jour
            # On consid√®re comme inactive
            return True

        try:
            # Parser le timestamp ISO
            last_activity = datetime.fromisoformat(last_activity_str.replace('Z', '+00:00'))
            current_time = datetime.now()

            # Si c'est un timestamp UTC, on doit le comparer √† UTC
            if '+' in last_activity_str or 'Z' in last_activity_str:
                from datetime import timezone
                current_time = datetime.now(timezone.utc)

            # Calculer la diff√©rence
            time_diff = current_time - last_activity
            inactive_minutes = time_diff.total_seconds() / 60

            # Session inactive si pas d'activit√© depuis plus de 3 minutes
            return inactive_minutes > 3.0

        except Exception as e:
            logger.warning(f"Erreur parsing last_activity: {e}")
            # En cas d'erreur, on consid√®re comme inactive par s√©curit√©
            return True

    def detect_and_fix_stuck_sessions(self):
        """D√©tecte et corrige les sessions bloqu√©es/gel√©es"""
        try:
            # R√©cup√©rer les sessions 'processing' qui pourraient √™tre gel√©es
            stuck_sessions = self.client.client.table("extraction_sessions")\
                .select("*")\
                .eq("status", "processing")\
                .execute()

            fixed_count = 0
            for session in stuck_sessions.data:
                session_id = session['id']
                session_name = session.get('session_name', 'N/A')

                # NOUVELLE LOGIQUE: V√©rifier d'abord si la session est r√©ellement inactive
                if not self._is_session_truly_inactive(session):
                    # Session encore active (activit√© r√©cente), on ne la touche pas
                    logger.debug(f"Session {session_name} encore active - ignor√©e par watchdog")
                    continue

                # Si on arrive ici, la session est r√©ellement inactive depuis >3min
                logger.info(f"Session inactive d√©tect√©e: {session_name} (>3min sans activit√©)")

                # V√©rifier les h√¥tels r√©els vs d√©clar√©s
                actual_hotels = self.client.client.table("hotels")\
                    .select("*")\
                    .eq("session_id", session_id)\
                    .execute()

                actual_count = len(actual_hotels.data)
                declared_count = session.get('total_hotels', 0)

                # Compter les h√¥tels termin√©s
                completed_hotels = [h for h in actual_hotels.data
                                   if h.get('extraction_status') == 'completed']

                # Cas 1: Tous les h√¥tels sont completed mais session encore processing
                if len(completed_hotels) == actual_count and actual_count > 0:
                    logger.warning(f"Session gel√©e d√©tect√©e: {session_name} - {actual_count} h√¥tels completed mais session en processing")
                    self.finalize_session(session_id, success=True)
                    fixed_count += 1
                    logger.info(f"Session {session_name} auto-finalis√©e ({actual_count} h√¥tels)")

                # Cas 2: Session inactive + donn√©es partielles (au moins quelques h√¥tels trait√©s)
                elif actual_count > 0:
                    logger.warning(f"Session incompl√®te inactive: {session_name} - {actual_count}/{declared_count} h√¥tels trait√©s, finalis√©e avec donn√©es partielles")
                    self.finalize_session(session_id, success=True)  # Succ√®s car on a des donn√©es
                    fixed_count += 1
                    logger.info(f"Session {session_name} finalis√©e avec donn√©es partielles ({actual_count}/{declared_count})")

                # Cas 3: Session inactive sans aucun h√¥tel trait√©
                else:
                    logger.warning(f"Session vide inactive: {session_name} - Aucun h√¥tel trait√©, marqu√©e √©chou√©e")
                    self.finalize_session(session_id, success=False)
                    fixed_count += 1
                    logger.info(f"Session {session_name} marqu√©e √©chou√©e (aucune donn√©e)")

            if fixed_count > 0:
                logger.info(f"Watchdog: {fixed_count} sessions gel√©es corrig√©es")

            return fixed_count

        except Exception as e:
            logger.error(f"Erreur watchdog sessions: {e}")
            return 0

    def finalize_session(
        self,
        session_id: str,
        success: bool = True,
        success_count: Optional[int] = None,
        error_count: Optional[int] = None
    ):
        """Finalise une session d'extraction

        Args:
            session_id: ID de la session
            success: Si la session s'est termin√©e avec succ√®s
            success_count: Nombre d'h√¥tels trait√©s avec succ√®s (optionnel)
            error_count: Nombre d'h√¥tels en erreur (optionnel)
        """
        logger.info(f"üîç DEBUT finalize_session pour session_id={session_id}, success={success}")
        try:
            # R√©cup√©rer le nombre r√©el d'h√¥tels dans la DB
            logger.info(f"üîç R√©cup√©ration des h√¥tels r√©els pour session {session_id}")
            hotels_query = self.client.client.table("hotels").select("*").eq("session_id", session_id).execute()
            hotels_data = hotels_query.data or []
            actual_count = len(hotels_data)
            logger.info(f"üîç Nombre d'h√¥tels r√©els trouv√©s: {actual_count}")

            # Comptage des statuts directement depuis la table h√¥tels
            completed_in_db = sum(1 for hotel in hotels_data
                                  if hotel.get('extraction_status') == 'completed')
            failed_in_db = sum(1 for hotel in hotels_data
                               if hotel.get('extraction_status') == 'failed')

            def _ensure_int(value, fallback=0):
                if value is None:
                    return fallback
                try:
                    return max(int(value), 0)
                except (TypeError, ValueError):
                    return fallback

            computed_success = _ensure_int(success_count, fallback=completed_in_db)
            computed_errors = _ensure_int(error_count, fallback=failed_in_db)

            processed_hotels = computed_success + computed_errors
            if processed_hotels > actual_count:
                processed_hotels = actual_count

            pending_hotels = max(actual_count - processed_hotels, 0)

            logger.info(
                "üîç Comptage final - success=%s, errors=%s, pending=%s",
                computed_success,
                computed_errors,
                pending_hotels
            )

            if success and actual_count > 0 and processed_hotels == 0:
                logger.warning(
                    "‚ö†Ô∏è Aucun h√¥tel comptabilis√© malgr√© le succ√®s annonc√© - fallback sur total r√©el"
                )
                processed_hotels = actual_count
                pending_hotels = 0

            # R√©cup√©rer la session actuelle
            logger.info(f"üîç R√©cup√©ration des donn√©es de session {session_id}")
            session_data = self.client.client.table("extraction_sessions").select("*").eq("id", session_id).execute()
            if not session_data.data:
                logger.error(f"Session {session_id} introuvable")
                return
            logger.info(f"üîç Donn√©es de session r√©cup√©r√©es")

            current_session = session_data.data[0]
            declared_total = current_session.get('total_hotels', 0)
            logger.info(f"üîç Total d√©clar√©: {declared_total}, Total r√©el: {actual_count}")

            # D√©tecter les incoh√©rences
            if actual_count != declared_total:
                logger.warning(f"Incoh√©rence d√©tect√©e: {actual_count} h√¥tels r√©els vs {declared_total} d√©clar√©s")
                # Corriger automatiquement en prenant la r√©alit√©
                status = "completed" if success and processed_hotels > 0 else "failed"
                logger.info(f"üîç Mise √† jour status session vers {status}")
                self.client.update_session_status(
                    session_id=session_id,
                    status=status,
                    processed_hotels=processed_hotels if processed_hotels > 0 else actual_count
                )
                logger.info(f"üîç Status mis √† jour, mise √† jour total_hotels")
                # Mettre √† jour le total pour correspondre √† la r√©alit√©
                logger.info(f"üîç AVANT UPDATE direct total_hotels={actual_count}")
                update_result = self.client.client.table("extraction_sessions").update({
                    'total_hotels': actual_count
                }).eq('id', session_id).execute()
                logger.info(f"üîç APRES UPDATE direct total_hotels - SUCCESS")
                logger.info(f"üîç Session {session_id} corrig√©e: {actual_count} h√¥tels r√©els")
            else:
                # Pas d'incoh√©rence, finalisation normale
                status = "completed" if success else "failed"
                stats_processed = 0
                stats = {}
                if success_count is None or error_count is None:
                    logger.info(f"üîç Finalisation normale, r√©cup√©ration des statistiques")
                    stats = self.get_session_statistics(session_id)
                    logger.info(f"üîç Statistiques r√©cup√©r√©es: {stats}")
                    stats_completed = _ensure_int(stats.get('completed'), fallback=0)
                    stats_failed = _ensure_int(stats.get('failed'), fallback=0)
                    stats_processed = stats_completed + stats_failed

                if stats_processed > 0:
                    logger.info(f"üîç Processed calcul√© via stats: {stats_processed}")
                    processed_hotels = max(processed_hotels, min(stats_processed, actual_count))
                    pending_hotels = max(actual_count - processed_hotels, 0)

                if not success and processed_hotels == 0 and actual_count > 0:
                    processed_hotels = actual_count - pending_hotels

                logger.info(
                    f"üîç Mise √† jour status final vers {status}, processed={processed_hotels}"
                )
                self.client.update_session_status(
                    session_id=session_id,
                    status=status,
                    processed_hotels=processed_hotels
                )
                logger.info(f"üîç Session {session_id} finalis√©e normalement: {status}")

            logger.info(f"üîç FIN finalize_session pour session_id={session_id} - SUCCESS")
        except Exception as e:
            logger.error(f"üîç ERREUR dans finalize_session pour session_id={session_id}: {e}")

    def get_batch_hotels_with_ids(
        self,
        session_id: str,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """R√©cup√®re un batch d'h√¥tels avec leurs IDs

        Args:
            session_id: ID de la session
            limit: Nombre max d'h√¥tels

        Returns:
            List[Dict]: Liste des h√¥tels avec leurs IDs DB
        """
        try:
            hotels = self.client.get_pending_hotels(session_id, limit)

            # Marquer comme en cours de traitement
            if hotels:
                hotel_ids = [h['id'] for h in hotels]
                self.client.mark_hotels_processing(hotel_ids)

            return hotels
        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration batch: {e}")
            return []

    def export_session_to_csv(
        self,
        session_id: str,
        include_empty_rooms: bool = False
    ) -> str:
        """Exporte toutes les donn√©es d'une session vers un CSV consolid√©

        Args:
            session_id: ID de la session √† exporter
            include_empty_rooms: Inclure les h√¥tels sans salles

        Returns:
            str: Contenu CSV format√©
        """
        try:
            # R√©cup√©rer tous les h√¥tels de la session
            hotels_query = (
                self.client.client
                .table("hotels")
                .select("*")
                .eq("session_id", session_id)
                .execute()
            )

            if not hotels_query.data:
                logger.warning(f"Aucun h√¥tel trouv√© pour session {session_id}")
                return self._create_empty_csv()

            # Pour chaque h√¥tel, r√©cup√©rer ses salles
            csv_rows = []

            for hotel in hotels_query.data:
                hotel_id = hotel['id']

                # R√©cup√©rer les salles de cet h√¥tel
                rooms_query = (
                    self.client.client
                    .table("meeting_rooms")
                    .select("*")
                    .eq("hotel_id", hotel_id)
                    .execute()
                )

                # Si pas de salles et qu'on n'inclut pas les h√¥tels vides
                if not rooms_query.data and not include_empty_rooms:
                    continue

                # Si pas de salles mais on inclut les h√¥tels vides
                if not rooms_query.data and include_empty_rooms:
                    csv_rows.append(self._create_csv_row(hotel, None))
                else:
                    # Une ligne par salle
                    for room in rooms_query.data:
                        csv_rows.append(self._create_csv_row(hotel, room))

            # Convertir en DataFrame puis CSV
            if not csv_rows:
                logger.info(f"Aucune donn√©e √† exporter pour session {session_id}")
                return self._create_empty_csv()

            df = pd.DataFrame(csv_rows)

            # Trier par nom d'h√¥tel puis nom de salle
            df = df.sort_values(['hotel_name', 'nom_salle'], na_position='last')

            # Convertir en CSV
            csv_buffer = io.StringIO()
            df.to_csv(csv_buffer, index=False, encoding='utf-8')
            csv_content = csv_buffer.getvalue()

            logger.info(
                f"Export CSV session {session_id}: {len(csv_rows)} lignes, "
                f"{len(hotels_query.data)} h√¥tels"
            )

            return csv_content

        except Exception as e:
            logger.error(f"Erreur export CSV session {session_id}: {e}")
            return self._create_error_csv(str(e))

    def _create_csv_row(self, hotel: Dict, room: Optional[Dict] = None) -> Dict:
        """Cr√©e une ligne CSV √† partir des donn√©es h√¥tel/salle

        Args:
            hotel: Donn√©es de l'h√¥tel depuis Supabase
            room: Donn√©es de la salle (optionnel)

        Returns:
            Dict: Ligne format√©e pour CSV
        """
        # Donn√©es de base de l'h√¥tel
        row = {
            'hotel_name': hotel.get('name', ''),
            'hotel_address': hotel.get('address', ''),
            'cvent_url': hotel.get('cvent_url', ''),
            'extraction_date': hotel.get('extraction_date', ''),
            'interface_type': hotel.get('interface_type', ''),
            'extraction_status': hotel.get('extraction_status', ''),
            'session_id': hotel.get('session_id', ''),
        }

        # R√©cup√©rer et ajouter donn√©es Google Maps si disponibles
        try:
            gmaps_data = self.client.client.table("hotel_gmaps_data").select("*").eq("hotel_id", hotel['id']).execute()
            if gmaps_data.data:
                gmaps_row = gmaps_data.data[0]
                row.update({
                    'gmaps_name': gmaps_row.get('gmaps_name', ''),
                    'gmaps_address': gmaps_row.get('gmaps_address', ''),
                    'gmaps_phone': gmaps_row.get('gmaps_phone', ''),
                    'gmaps_rating': gmaps_row.get('gmaps_rating', ''),
                    'gmaps_website': gmaps_row.get('gmaps_website', ''),
                })
            else:
                row.update({
                    'gmaps_name': '', 'gmaps_address': '', 'gmaps_phone': '',
                    'gmaps_rating': '', 'gmaps_website': ''
                })
        except:
            row.update({
                'gmaps_name': '', 'gmaps_address': '', 'gmaps_phone': '',
                'gmaps_rating': '', 'gmaps_website': ''
            })

        # R√©cup√©rer et ajouter donn√©es Website/LLM si disponibles
        try:
            website_data = self.client.client.table("hotel_website_data").select("*").eq("hotel_id", hotel['id']).execute()
            if website_data.data:
                website_row = website_data.data[0]
                row.update({
                    'website_url': website_row.get('website_url', ''),
                    'website_phone': website_row.get('website_phone', ''),
                    'website_email': website_row.get('website_email', ''),
                    'price_range': website_row.get('price_range', ''),
                    'nombre_chambre': website_row.get('nombre_chambre', ''),
                    'nombre_etoile': website_row.get('nombre_etoile', ''),
                    'parking': website_row.get('pr_parking', ''),
                    'restaurant': website_row.get('pr_restaurant', ''),
                    'spa': website_row.get('pr_spa', ''),
                    'wifi': website_row.get('pr_wifi', ''),
                })
            else:
                row.update({
                    'website_url': '', 'website_phone': '', 'website_email': '',
                    'price_range': '', 'nombre_chambre': '', 'nombre_etoile': '',
                    'parking': '', 'restaurant': '', 'spa': '', 'wifi': ''
                })
        except:
            row.update({
                'website_url': '', 'website_phone': '', 'website_email': '',
                'price_range': '', 'nombre_chambre': '', 'nombre_etoile': '',
                'parking': '', 'restaurant': '', 'spa': '', 'wifi': ''
            })

        # Donn√©es de la salle si disponible
        if room:
            row.update({
                'nom_salle': room.get('nom_salle', ''),
                'surface': room.get('surface', ''),
                'capacite_theatre': room.get('capacite_theatre', ''),
                'capacite_classe': room.get('capacite_classe', ''),
                'capacite_banquet': room.get('capacite_banquet', ''),
                'capacite_cocktail': room.get('capacite_cocktail', ''),
                'capacite_u': room.get('capacite_u', ''),
                'capacite_amphi': room.get('capacite_amphi', ''),
            })
        else:
            # H√¥tel sans salles
            row.update({
                'nom_salle': '',
                'surface': '',
                'capacite_theatre': '',
                'capacite_classe': '',
                'capacite_banquet': '',
                'capacite_cocktail': '',
                'capacite_u': '',
                'capacite_amphi': '',
            })

        return row

    def _create_empty_csv(self) -> str:
        """Cr√©e un CSV vide avec les headers"""
        headers = [
            'hotel_name', 'hotel_address', 'cvent_url', 'extraction_date',
            'interface_type', 'extraction_status', 'session_id',
            'gmaps_name', 'gmaps_address', 'gmaps_phone', 'gmaps_rating', 'gmaps_website',
            'website_url', 'website_phone', 'website_email', 'price_range',
            'nombre_chambre', 'nombre_etoile', 'parking', 'restaurant', 'spa', 'wifi',
            'nom_salle', 'surface', 'capacite_theatre', 'capacite_classe',
            'capacite_banquet', 'capacite_cocktail', 'capacite_u', 'capacite_amphi'
        ]

        df = pd.DataFrame(columns=headers)
        csv_buffer = io.StringIO()
        df.to_csv(csv_buffer, index=False, encoding='utf-8')
        return csv_buffer.getvalue()

    def _create_error_csv(self, error_message: str) -> str:
        """Cr√©e un CSV d'erreur avec un message"""
        error_data = [{
            'hotel_name': f'ERREUR: {error_message}',
            'hotel_address': '',
            'cvent_url': '',
            'extraction_date': datetime.now().isoformat(),
            'interface_type': '',
            'extraction_status': 'error',
            'session_id': '',
            'gmaps_name': '', 'gmaps_address': '', 'gmaps_phone': '',
            'gmaps_rating': '', 'gmaps_website': '',
            'website_url': '', 'website_phone': '', 'website_email': '', 'price_range': '',
            'nombre_chambre': '', 'nombre_etoile': '', 'parking': '', 'restaurant': '', 'spa': '', 'wifi': '',
            'nom_salle': '', 'surface': '', 'capacite_theatre': '',
            'capacite_classe': '', 'capacite_banquet': '', 'capacite_cocktail': '',
            'capacite_u': '', 'capacite_amphi': ''
        }]

        df = pd.DataFrame(error_data)
        csv_buffer = io.StringIO()
        df.to_csv(csv_buffer, index=False, encoding='utf-8')
        return csv_buffer.getvalue()

    def get_session_export_stats(self, session_id: str) -> Dict[str, Any]:
        """R√©cup√®re les statistiques d'une session pour l'export

        Args:
            session_id: ID de la session

        Returns:
            Dict: Statistiques d√©taill√©es
        """
        try:
            # Compter les h√¥tels
            hotels_count = (
                self.client.client
                .table("hotels")
                .select("id", count="exact")
                .eq("session_id", session_id)
                .execute()
            )

            # Compter les h√¥tels avec donn√©es
            hotels_with_data = (
                self.client.client
                .table("hotels")
                .select("id", count="exact")
                .eq("session_id", session_id)
                .eq("extraction_status", "completed")
                .execute()
            )

            # Compter les salles totales
            hotels_ids = [h['id'] for h in
                         self.client.client
                         .table("hotels")
                         .select("id")
                         .eq("session_id", session_id)
                         .execute().data]

            total_rooms = 0
            if hotels_ids:
                rooms_count = (
                    self.client.client
                    .table("meeting_rooms")
                    .select("id", count="exact")
                    .in_("hotel_id", hotels_ids)
                    .execute()
                )
                total_rooms = rooms_count.count or 0

            return {
                'session_id': session_id,
                'total_hotels': hotels_count.count or 0,
                'hotels_with_data': hotels_with_data.count or 0,
                'total_rooms': total_rooms,
                'export_ready': total_rooms > 0
            }

        except Exception as e:
            logger.error(f"Erreur stats export session {session_id}: {e}")
            return {
                'session_id': session_id,
                'total_hotels': 0,
                'hotels_with_data': 0,
                'total_rooms': 0,
                'export_ready': False,
                'error': str(e)
            }